<!--
    Chip Factory Game
    Copyright (c) 2025 Harsh Meena (harshmiitk@gmail.com)
    All rights reserved.
    
    This game is protected by copyright law and international treaties.
    Unauthorized reproduction or distribution of this game or any portion of it
    may result in severe civil and criminal penalties.
    
    GitHub: https://github.com/[your-username]/chip-factory-game
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Harsh Meena">
    <meta name="copyright" content="Copyright (c) 2025 Harsh Meena. All rights reserved.">
    <title>Chip Factory - Learn How Computer Chips Are Made</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000000;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #main-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            padding: 15px;
            max-width: 1400px;
            width: 100%;
            height: 100vh;
            max-height: 800px;
        }
        
        /* Left Panel - Game */
        #game-section {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        #game-header {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        h1 {
            font-size: 24px;
            font-weight: 600;
            letter-spacing: -0.5px;
        }
        
        .tutorial-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ffffff;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tutorial-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        canvas {
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            background: #0a0a0a;
        }
        
        #score-bar {
            display: flex;
            gap: 25px;
            padding: 14px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }
        
        .score-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .score-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .score-value {
            font-size: 24px;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }
        
        /* Middle Panel - Info */
        #info-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 16px;
            max-width: 400px;
        }
        
        .device-selector {
            display: flex;
            gap: 12px;
            padding: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        
        .device-btn {
            flex: 1;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            padding: 12px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 500;
        }
        
        .device-btn:hover {
            color: #ffffff;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .device-btn.active {
            background: #ffffff;
            color: #000000;
        }
        
        .progress-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .progress-title {
            font-size: 14px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .progress-percentage {
            font-size: 14px;
            font-weight: 600;
        }
        
        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007AFF, #5AC8FA);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .layer-info {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
        }
        
        .layer-current {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 8px;
            color: #5AC8FA;
        }
        
        .layer-description {
            font-size: 14px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 12px;
        }
        
        .layer-fact {
            font-size: 13px;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.6);
            padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            border-left: 3px solid #5AC8FA;
        }
        
        .controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
        }
        
        .controls-title {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 12px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 8px 0;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .key {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            min-width: 24px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* Right Panel - Blueprint */
        #blueprint-section {
            flex: 0 0 320px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .blueprint-container {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
        }
        
        .blueprint-title {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 16px;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        #blueprint-canvas {
            border-radius: 8px;
            background: #0a0a0a;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .layer-list {
            margin-top: 16px;
        }
        
        .layer-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.2s;
        }
        
        .layer-item.active {
            color: #5AC8FA;
            font-weight: 500;
        }
        
        .layer-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
        }
        
        .layer-item.active .layer-indicator {
            background: #5AC8FA;
            box-shadow: 0 0 8px rgba(90, 200, 250, 0.5);
        }
        
        .layer-item.completed .layer-indicator {
            background: #34C759;
        }
        
        /* Floating elements */
        .bonus-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: 700;
            background: linear-gradient(135deg, #FFD60A, #FFC500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 4px 20px rgba(255, 214, 10, 0.5);
            pointer-events: none;
            opacity: 0;
            white-space: nowrap;
        }
        
        .bonus-active {
            animation: bonusAnimation 1.2s ease-out;
        }
        
        @keyframes bonusAnimation {
            0% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.5) rotate(-10deg); 
            }
            50% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.1) rotate(5deg); 
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(1) rotate(0deg) translateY(-50px); 
            }
        }
        
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .tutorial-content {
            background: #1a1a1a;
            border-radius: 16px;
            padding: 40px;
            max-width: 600px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .tutorial-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 20px;
        }
        
        .tutorial-text {
            font-size: 16px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 30px;
        }
        
        .tutorial-next {
            background: #007AFF;
            color: white;
            border: none;
            padding: 12px 32px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tutorial-next:hover {
            background: #0051D5;
            transform: translateY(-1px);
        }
        
        .restart-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.7);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 16px;
        }
        
        .restart-btn:hover {
            border-color: rgba(255, 255, 255, 0.4);
            color: #ffffff;
        }
    </style>
</head>
<body>
    <div id="main-container">
        <!-- Left: Game -->
        <div id="game-section">
            <div id="game-header">
                <h1>Chip Factory</h1>
                <button class="tutorial-btn" onclick="showTutorial()">Tutorial</button>
            </div>
            <canvas id="gameCanvas" width="300" height="600"></canvas>
            <div id="score-bar">
                <div class="score-item">
                    <div class="score-label">Score</div>
                    <div class="score-value" id="score">0</div>
                </div>
                <div class="score-item">
                    <div class="score-label">Chips Built</div>
                    <div class="score-value" id="devices">0</div>
                </div>
                <div class="score-item">
                    <div class="score-label">Perfect</div>
                    <div class="score-value" id="perfect">0</div>
                </div>
            </div>
        </div>
        
        <!-- Middle: Info -->
        <div id="info-section">
            <div class="device-selector">
                <button class="device-btn active" onclick="selectDevice('transistor')">Switch</button>
                <button class="device-btn" onclick="selectDevice('memory')">Memory</button>
                <button class="device-btn" onclick="selectDevice('power')">Power</button>
            </div>
            
            <div class="progress-container">
                <div class="progress-header">
                    <div class="progress-title">Building Progress</div>
                    <div class="progress-percentage" id="progress-text">0%</div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress"></div>
                </div>
            </div>
            
            <div class="layer-info">
                <div class="layer-current" id="current-layer">Starting Layer</div>
                <div class="layer-description" id="layer-description">
                    Get ready to build your first chip!
                </div>
                <div class="layer-fact" id="layer-fact">
                    üí° Chips power everything from your phone to your car!
                </div>
            </div>
            
            <div class="controls">
                <div class="controls-title">How to Play</div>
                <div class="control-row">
                    <span class="key">‚Üê</span>
                    <span class="key">‚Üí</span>
                    <span>Move pieces</span>
                </div>
                <div class="control-row">
                    <span class="key">‚Üì</span>
                    <span>Drop faster</span>
                </div>
                <div class="control-row">
                    <span class="key">Space</span>
                    <span>Instant drop</span>
                </div>
                <div class="control-row">
                    <span class="key">P</span>
                    <span>Pause game</span>
                </div>
            </div>
            
            <button class="restart-btn" onclick="restartGame()">New Game</button>
        </div>
        
        <!-- Right: Blueprint -->
        <div id="blueprint-section">
            <div class="blueprint-container">
                <div class="blueprint-title">Build Pattern</div>
                <canvas id="blueprint-canvas" width="280" height="300"></canvas>
                <div class="layer-list" id="layer-list">
                    <!-- Layers will be added dynamically -->
                </div>
            </div>
        </div>
    </div>
    
    <div id="bonus-indicator" class="bonus-popup"></div>
    
    <div id="tutorial-overlay" class="tutorial-overlay">
        <div class="tutorial-content">
            <h2 class="tutorial-title" id="tutorial-title">Welcome to Chip Factory!</h2>
            <p class="tutorial-text" id="tutorial-text">
                Learn how computer chips are made by building them layer by layer, 
                just like in a real semiconductor factory!
            </p>
            <button class="tutorial-next" onclick="nextTutorial()">Next</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const blueprintCanvas = document.getElementById('blueprint-canvas');
        const bpCtx = blueprintCanvas.getContext('2d');
        
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        
        // Simplified devices with fun facts
        const DEVICES = {
            transistor: {
                name: 'Electronic Switch',
                icon: 'üîå',
                description: 'The basic on/off switch that powers all computing',
                width: 6,
                height: 8,
                layers: [
                    {
                        name: 'Base Layer',
                        color: '#6366F1',
                        pattern: [
                            [1,1,1,1,1,1],
                            [1,1,1,1,1,1],
                            [1,1,1,1,1,1]
                        ],
                        description: 'Silicon foundation - like a pizza base',
                        fact: 'Silicon comes from sand! Beach sand becomes computer chips.'
                    },
                    {
                        name: 'Electric Paths',
                        color: '#F59E0B',
                        pattern: [
                            [1,1,0,0,1,1],
                            [1,0,0,0,0,1],
                            [1,0,0,0,0,1]
                        ],
                        description: 'Pathways for electricity to flow',
                        fact: 'These paths are 10,000x thinner than human hair!'
                    },
                    {
                        name: 'Insulation',
                        color: '#3B82F6',
                        pattern: [
                            [0,0,1,1,0,0],
                            [0,1,1,1,1,0]
                        ],
                        description: 'A super-thin wall that blocks electricity',
                        fact: 'This layer is only 30 atoms thick - incredible precision!'
                    },
                    {
                        name: 'Control Gate',
                        color: '#EF4444',
                        pattern: [
                            [0,0,1,1,0,0],
                            [0,1,1,1,1,0]
                        ],
                        description: 'The switch that turns electricity on/off',
                        fact: 'This switch can flip 5 billion times per second!'
                    },
                    {
                        name: 'Metal Wires',
                        color: '#9CA3AF',
                        pattern: [
                            [1,0,0,0,0,1],
                            [0,1,0,0,1,0],
                            [0,0,1,1,0,0]
                        ],
                        description: 'Tiny metal highways connecting everything',
                        fact: 'A chip has millions of wires - like a tiny city!'
                    },
                    {
                        name: 'Protection',
                        color: '#10B981',
                        pattern: [
                            [1,1,1,1,1,1],
                            [1,1,1,1,1,1]
                        ],
                        description: 'Protective shield keeping the chip safe',
                        fact: 'This coating protects against dust particles and moisture.'
                    }
                ]
            },
            memory: {
                name: 'Memory Cell',
                icon: 'üíæ',
                description: 'Stores information like a tiny filing cabinet',
                width: 5,
                height: 7,
                layers: [
                    {
                        name: 'Storage Base',
                        color: '#8B5CF6',
                        pattern: [
                            [1,1,1,1,1],
                            [1,0,0,0,1],
                            [1,1,1,1,1]
                        ],
                        description: 'Foundation for storing data',
                        fact: 'Each cell can store one bit - a 0 or 1!'
                    },
                    {
                        name: 'Memory Gate',
                        color: '#EC4899',
                        pattern: [
                            [0,1,0,1,0],
                            [1,1,1,1,1]
                        ],
                        description: 'The door that opens to read/write data',
                        fact: 'Opens and closes millions of times per second!'
                    },
                    {
                        name: 'Data Keeper',
                        color: '#06B6D4',
                        pattern: [
                            [1,0,1,0,1],
                            [0,1,0,1,0],
                            [1,0,1,0,1]
                        ],
                        description: 'Holds your data even when power is off',
                        fact: 'Like a tiny magnet that remembers its position!'
                    },
                    {
                        name: 'Connections',
                        color: '#F59E0B',
                        pattern: [
                            [0,1,1,1,0],
                            [1,0,0,0,1]
                        ],
                        description: 'Links to share data with the processor',
                        fact: 'Data travels at nearly the speed of light here!'
                    },
                    {
                        name: 'Shield',
                        color: '#10B981',
                        pattern: [
                            [1,1,1,1,1],
                            [1,1,1,1,1]
                        ],
                        description: 'Protects stored information',
                        fact: 'Prevents data corruption from cosmic rays!'
                    }
                ]
            },
            power: {
                name: 'Power Manager',
                icon: '‚ö°',
                description: 'Controls and distributes power efficiently',
                width: 7,
                height: 6,
                layers: [
                    {
                        name: 'Power Base',
                        color: '#DC2626',
                        pattern: [
                            [1,1,1,1,1,1,1],
                            [1,0,0,1,0,0,1],
                            [1,1,1,1,1,1,1]
                        ],
                        description: 'Receives power from the battery',
                        fact: 'Modern chips use less power than a small LED!'
                    },
                    {
                        name: 'Voltage Control',
                        color: '#7C3AED',
                        pattern: [
                            [0,1,0,1,0,1,0],
                            [1,1,1,1,1,1,1],
                            [0,1,0,1,0,1,0]
                        ],
                        description: 'Adjusts power like a volume knob',
                        fact: 'Can change voltage 1000 times per second!'
                    },
                    {
                        name: 'Distribution',
                        color: '#2563EB',
                        pattern: [
                            [1,0,0,0,0,0,1],
                            [0,1,0,0,0,1,0],
                            [0,0,1,1,1,0,0]
                        ],
                        description: 'Sends power where it\'s needed',
                        fact: 'Like a smart power grid for your chip!'
                    },
                    {
                        name: 'Efficiency',
                        color: '#059669',
                        pattern: [
                            [0,0,1,1,1,0,0],
                            [0,1,0,0,0,1,0],
                            [1,0,0,0,0,0,1]
                        ],
                        description: 'Makes sure no power is wasted',
                        fact: 'Saves enough power to extend battery life by hours!'
                    },
                    {
                        name: 'Protection',
                        color: '#10B981',
                        pattern: [
                            [1,1,1,1,1,1,1],
                            [1,1,1,1,1,1,1]
                        ],
                        description: 'Prevents power surges and damage',
                        fact: 'Protects against voltage spikes in nanoseconds!'
                    }
                ]
            }
        };
        
        const TUTORIAL_STEPS = [
            {
                title: "Welcome to Chip Factory!",
                text: "Learn how computer chips are made by building them layer by layer, just like in a real semiconductor factory!"
            },
            {
                title: "Follow the Blueprint",
                text: "Look at the pattern on the right. Each colored layer needs to be placed in the right spot - just like stacking LEGO blocks!"
            },
            {
                title: "Perfect Placement = Big Points!",
                text: "When pieces glow green, they're perfectly aligned. Drop them there for bonus points!"
            },
            {
                title: "Build Different Chips",
                text: "Try building all three types: Switches (transistors), Memory cells, and Power managers. Each teaches you something new!"
            },
            {
                title: "You're Ready!",
                text: "Start building chips and discover fun facts about the technology inside every device you use. Good luck!"
            }
        ];
        
        let board = [];
        let currentDevice = 'transistor';
        let currentLayerIndex = 0;
        let currentPiece = null;
        let score = 0;
        let devicesBuilt = 0;
        let perfectPlacements = 0;
        let isPaused = false;
        let dropCounter = 0;
        let lastTime = 0;
        let deviceStartX = 3;
        let deviceStartY = 14;
        let tutorialStep = 0;
        
        class Piece {
            constructor() {
                const device = DEVICES[currentDevice];
                const layer = device.layers[currentLayerIndex];
                this.pattern = layer.pattern;
                this.color = layer.color;
                this.name = layer.name;
                this.x = deviceStartX;
                this.y = 0;
                this.targetY = deviceStartY + this.getLayerOffset();
            }
            
            getLayerOffset() {
                const device = DEVICES[currentDevice];
                let offset = 0;
                for (let i = 0; i < currentLayerIndex; i++) {
                    offset += device.layers[i].pattern.length;
                }
                return offset;
            }
            
            collides() {
                for (let row = 0; row < this.pattern.length; row++) {
                    for (let col = 0; col < this.pattern[row].length; col++) {
                        if (this.pattern[row][col]) {
                            const boardX = this.x + col;
                            const boardY = this.y + row;
                            
                            if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
                                return true;
                            }
                            
                            if (boardY >= 0 && board[boardY][boardX]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            isAligned() {
                return this.x === deviceStartX && this.y === this.targetY;
            }
        }
        
        function initBoard() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            currentLayerIndex = 0;
            updateDeviceBlueprint();
            updateLayerInfo();
        }
        
        function drawBlock(x, y, color, context = ctx, size = BLOCK_SIZE) {
            const xPos = x * size;
            const yPos = y * size;
            const padding = 1;
            
            // Main block
            context.fillStyle = color;
            context.fillRect(xPos + padding, yPos + padding, size - padding * 2, size - padding * 2);
            
            // Subtle inner shadow
            const gradient = context.createLinearGradient(xPos, yPos + size, xPos, yPos);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            context.fillStyle = gradient;
            context.fillRect(xPos + padding, yPos + padding, size - padding * 2, size - padding * 2);
        }
        
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Subtle grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * BLOCK_SIZE, 0);
                ctx.lineTo(i * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * BLOCK_SIZE);
                ctx.lineTo(canvas.width, i * BLOCK_SIZE);
                ctx.stroke();
            }
            
            // Draw placement guide
            if (currentPiece && !isPaused) {
                ctx.fillStyle = 'rgba(90, 200, 250, 0.1)';
                for (let row = 0; row < currentPiece.pattern.length; row++) {
                    for (let col = 0; col < currentPiece.pattern[row].length; col++) {
                        if (currentPiece.pattern[row][col]) {
                            ctx.fillRect(
                                (deviceStartX + col) * BLOCK_SIZE,
                                (currentPiece.targetY + row) * BLOCK_SIZE,
                                BLOCK_SIZE,
                                BLOCK_SIZE
                            );
                        }
                    }
                }
            }
            
            // Draw board
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (board[row][col]) {
                        drawBlock(col, row, board[row][col]);
                    }
                }
            }
            
            // Draw current piece
            if (currentPiece && !isPaused) {
                for (let row = 0; row < currentPiece.pattern.length; row++) {
                    for (let col = 0; col < currentPiece.pattern[row].length; col++) {
                        if (currentPiece.pattern[row][col]) {
                            drawBlock(
                                currentPiece.x + col,
                                currentPiece.y + row,
                                currentPiece.color
                            );
                        }
                    }
                }
                
                // Perfect alignment glow
                if (currentPiece.isAligned()) {
                    ctx.strokeStyle = '#34C759';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(
                        currentPiece.x * BLOCK_SIZE,
                        currentPiece.y * BLOCK_SIZE,
                        currentPiece.pattern[0].length * BLOCK_SIZE,
                        currentPiece.pattern.length * BLOCK_SIZE
                    );
                }
            }
        }
        
        function updateDeviceBlueprint() {
            const device = DEVICES[currentDevice];
            
            // Clear blueprint
            bpCtx.fillStyle = '#0a0a0a';
            bpCtx.fillRect(0, 0, blueprintCanvas.width, blueprintCanvas.height);
            
            // Calculate scale and position
            let totalHeight = 0;
            device.layers.forEach(layer => totalHeight += layer.pattern.length);
            const scale = Math.min(25, (blueprintCanvas.height - 40) / totalHeight);
            const xOffset = (blueprintCanvas.width - device.width * scale) / 2;
            const startY = (blueprintCanvas.height - totalHeight * scale) / 2;
            
            // Draw layers
            let yOffset = startY;
            device.layers.forEach((layer, index) => {
                layer.pattern.forEach((row, rowIndex) => {
                    row.forEach((cell, colIndex) => {
                        if (cell) {
                            const opacity = index <= currentLayerIndex ? 1 : 0.2;
                            bpCtx.globalAlpha = opacity;
                            drawBlock(
                                xOffset / scale + colIndex,
                                yOffset / scale + rowIndex,
                                layer.color,
                                bpCtx,
                                scale
                            );
                            bpCtx.globalAlpha = 1;
                        }
                    });
                });
                yOffset += layer.pattern.length * scale;
            });
            
            // Update layer list
            const layerList = document.getElementById('layer-list');
            layerList.innerHTML = device.layers.map((layer, index) => `
                <div class="layer-item ${index === currentLayerIndex ? 'active' : ''} ${index < currentLayerIndex ? 'completed' : ''}">
                    <div class="layer-indicator"></div>
                    <span>${index + 1}. ${layer.name}</span>
                </div>
            `).join('');
        }
        
        function updateLayerInfo() {
            const device = DEVICES[currentDevice];
            const layer = device.layers[currentLayerIndex];
            
            document.getElementById('current-layer').textContent = `Layer ${currentLayerIndex + 1}: ${layer.name}`;
            document.getElementById('layer-description').textContent = layer.description;
            document.getElementById('layer-fact').textContent = `üí° ${layer.fact}`;
        }
        
        function updateProgress() {
            const device = DEVICES[currentDevice];
            const progress = (currentLayerIndex / device.layers.length) * 100;
            
            document.getElementById('progress').style.width = progress + '%';
            document.getElementById('progress-text').textContent = Math.round(progress) + '%';
        }
        
        function lockPiece() {
            const isPerfect = currentPiece.isAligned();
            
            // Lock piece to board
            for (let row = 0; row < currentPiece.pattern.length; row++) {
                for (let col = 0; col < currentPiece.pattern[row].length; col++) {
                    if (currentPiece.pattern[row][col]) {
                        const boardY = currentPiece.y + row;
                        const boardX = currentPiece.x + col;
                        if (boardY >= 0 && boardY < ROWS && boardX >= 0 && boardX < COLS) {
                            board[boardY][boardX] = currentPiece.color;
                        }
                    }
                }
            }
            
            // Scoring
            if (isPerfect) {
                score += 500;
                perfectPlacements++;
                showBonus('PERFECT! +500');
            } else {
                score += 100;
            }
            
            // Next layer
            currentLayerIndex++;
            
            if (currentLayerIndex >= DEVICES[currentDevice].layers.length) {
                completeDevice();
            } else {
                updateProgress();
                updateLayerInfo();
                spawnPiece();
            }
            
            updateScore();
            updateDeviceBlueprint();
        }
        
        function completeDevice() {
            devicesBuilt++;
            score += 2000;
            showBonus(`${DEVICES[currentDevice].icon} CHIP COMPLETE!`);
            
            // Clear some rows
            for (let i = 0; i < 8; i++) {
                board.pop();
                board.unshift(Array(COLS).fill(0));
            }
            
            // Reset
            currentLayerIndex = 0;
            const device = DEVICES[currentDevice];
            deviceStartX = Math.floor(Math.random() * (COLS - device.width));
            
            updateProgress();
            updateLayerInfo();
            updateScore();
            spawnPiece();
        }
        
        function showBonus(text) {
            const indicator = document.getElementById('bonus-indicator');
            indicator.textContent = text;
            indicator.classList.remove('bonus-active');
            void indicator.offsetWidth; // Force reflow
            indicator.classList.add('bonus-active');
        }
        
        function spawnPiece() {
            currentPiece = new Piece();
            if (currentPiece.collides()) {
                gameOver();
            }
        }
        
        function gameOver() {
            isPaused = true;
            setTimeout(() => {
                showBonus(`Game Over! Score: ${score}`);
                setTimeout(restartGame, 3000);
            }, 100);
        }
        
        function drop() {
            currentPiece.y++;
            if (currentPiece.collides()) {
                currentPiece.y--;
                lockPiece();
            }
            dropCounter = 0;
        }
        
        function movePiece(dir) {
            currentPiece.x += dir;
            if (currentPiece.collides()) {
                currentPiece.x -= dir;
            }
        }
        
        function hardDrop() {
            while (!currentPiece.collides()) {
                currentPiece.y++;
            }
            currentPiece.y--;
            lockPiece();
        }
        
        function updateScore() {
            document.getElementById('score').textContent = score.toLocaleString();
            document.getElementById('devices').textContent = devicesBuilt;
            document.getElementById('perfect').textContent = perfectPlacements;
        }
        
        function selectDevice(device) {
            if (device === currentDevice) return;
            
            currentDevice = device;
            currentLayerIndex = 0;
            
            // Update UI
            document.querySelectorAll('.device-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Reset game
            const dev = DEVICES[device];
            deviceStartX = Math.floor((COLS - dev.width) / 2);
            let totalHeight = 0;
            dev.layers.forEach(layer => totalHeight += layer.pattern.length);
            deviceStartY = ROWS - totalHeight - 2;
            
            initBoard();
            updateProgress();
            spawnPiece();
        }
        
        function restartGame() {
            initBoard();
            score = 0;
            devicesBuilt = 0;
            perfectPlacements = 0;
            isPaused = false;
            currentLayerIndex = 0;
            updateScore();
            updateProgress();
            spawnPiece();
        }
        
        function showTutorial() {
            tutorialStep = 0;
            document.getElementById('tutorial-overlay').style.display = 'flex';
            updateTutorial();
        }
        
        function updateTutorial() {
            const step = TUTORIAL_STEPS[tutorialStep];
            document.getElementById('tutorial-title').textContent = step.title;
            document.getElementById('tutorial-text').textContent = step.text;
        }
        
        function nextTutorial() {
            tutorialStep++;
            if (tutorialStep >= TUTORIAL_STEPS.length) {
                document.getElementById('tutorial-overlay').style.display = 'none';
            } else {
                updateTutorial();
            }
        }
        
        function gameLoop(time = 0) {
            if (!isPaused) {
                const deltaTime = time - lastTime;
                lastTime = time;
                
                dropCounter += deltaTime;
                if (dropCounter > 800) {
                    drop();
                }
                
                draw();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (isPaused && e.key !== 'p' && e.key !== 'P') return;
            
            switch(e.key.toLowerCase()) {
                case 'arrowleft':
                    movePiece(-1);
                    break;
                case 'arrowright':
                    movePiece(1);
                    break;
                case 'arrowdown':
                    drop();
                    break;
                case ' ':
                    e.preventDefault();
                    hardDrop();
                    break;
                case 'p':
                    isPaused = !isPaused;
                    break;
            }
        });
        
        // Initialize game
        initBoard();
        spawnPiece();
        gameLoop();
    </script>
</body>
</html>