<!--
    Chip Factory Game - Fixed Version
    Copyright (c) 2025 Harsh Meena (harshmiitk@gmail.com)
    All rights reserved.
    
    GitHub: https://github.com/meanharsh/chip-factory-game
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Harsh Meena">
    <meta name="copyright" content="Copyright (c) 2025 Harsh Meena. All rights reserved.">
    <title>Chip Factory - Learn How Computer Chips Are Made</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #main-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            padding: 15px;
            max-width: 1400px;
            width: 100%;
            height: 100vh;
            max-height: 900px;
        }
        
        /* Left Panel - Game */
        #game-section {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        #game-header {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        h1 {
            font-size: 24px;
            font-weight: 600;
            letter-spacing: -0.5px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .tutorial-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ffffff;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tutorial-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }
        
        canvas {
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            background: #0a0a0a;
            border: 2px solid rgba(102, 126, 234, 0.2);
        }
        
        #score-bar {
            display: flex;
            gap: 25px;
            padding: 14px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }
        
        .score-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .score-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .score-value {
            font-size: 24px;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }
        
        /* Middle Panel - Info */
        #info-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 16px;
            max-width: 400px;
        }
        
        .device-selector {
            display: flex;
            gap: 12px;
            padding: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        
        .device-btn {
            flex: 1;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            padding: 12px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 500;
        }
        
        .device-btn:hover:not(.active) {
            color: #ffffff;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .device-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            cursor: default;
        }
        
        .progress-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .progress-title {
            font-size: 14px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .progress-percentage {
            font-size: 14px;
            font-weight: 600;
        }
        
        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .layer-info {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
        }
        
        .layer-current {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .layer-description {
            font-size: 14px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 12px;
        }
        
        .layer-fact {
            font-size: 13px;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.6);
            padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            border-left: 3px solid #667eea;
        }
        
        .controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
        }
        
        .controls-title {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 12px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 8px 0;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .key {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            min-width: 24px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* Right Panel - Blueprint */
        #blueprint-section {
            flex: 0 0 320px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .blueprint-container {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
        }
        
        .blueprint-title {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 16px;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        #blueprint-canvas {
            border-radius: 8px;
            background: #0a0a0a;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .blueprint-explanation {
            margin-top: 12px;
            padding: 12px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .layer-list {
            margin-top: 16px;
        }
        
        .layer-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.2s;
        }
        
        .layer-item.active {
            color: #667eea;
            font-weight: 500;
        }
        
        .layer-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
        }
        
        .layer-item.active .layer-indicator {
            background: #667eea;
            box-shadow: 0 0 8px rgba(102, 126, 234, 0.5);
        }
        
        .layer-item.completed .layer-indicator {
            background: #34C759;
        }
        
        /* Popups */
        .popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.95), rgba(118, 75, 162, 0.95));
            border-radius: 16px;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            display: none;
        }
        
        .popup.active {
            display: block;
        }
        
        .popup h2 {
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .popup p {
            font-size: 16px;
            margin-bottom: 20px;
            max-width: 400px;
        }
        
        .popup button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .popup button:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .popup-detail {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.85);
            margin-top: 8px;
        }
        
        .bonus-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            font-weight: 700;
            background: linear-gradient(135deg, #FFD60A, #FFC500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            pointer-events: none;
            opacity: 0;
            white-space: nowrap;
            z-index: 999;
        }
        
        .bonus-active {
            animation: bonusAnimation 1.2s ease-out;
        }
        
        @keyframes bonusAnimation {
            0% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.5) rotate(-10deg); 
            }
            50% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.1) rotate(5deg); 
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(1) rotate(0deg) translateY(-50px); 
            }
        }
        
        @keyframes shortCircuit {
            0%, 100% { background: #0a0a0a; }
            25% { background: rgba(255, 0, 0, 0.2); }
            50% { background: #0a0a0a; }
            75% { background: rgba(255, 0, 0, 0.1); }
        }
        
        .short-circuit {
            animation: shortCircuit 0.5s ease-out;
        }
        
        .restart-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.7);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 16px;
            width: 100%;
        }
        
        .restart-btn:hover {
            border-color: rgba(102, 126, 234, 0.5);
            color: #ffffff;
            background: rgba(102, 126, 234, 0.1);
        }
        
        /* Debug Panel (hidden by default) */
        .debug-panel {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #667eea;
            border-radius: 8px;
            padding: 10px;
            font-size: 11px;
            font-family: monospace;
            display: none;
            max-width: 300px;
        }
        
        .debug-panel.active {
            display: block;
        }
    </style>
</head>
<body>
    <div id="main-container">
        <!-- Left: Game -->
        <div id="game-section">
            <div id="game-header">
                <h1>üî¨ Chip Factory</h1>
                <button class="tutorial-btn" onclick="game.showTutorial()">üìñ How to Play</button>
            </div>
            <canvas id="gameCanvas" width="300" height="600"></canvas>
            <div id="score-bar">
                <div class="score-item">
                    <div class="score-label">Score</div>
                    <div class="score-value" id="score">0</div>
                </div>
                <div class="score-item">
                    <div class="score-label">Chips</div>
                    <div class="score-value" id="devices">0</div>
                </div>
                <div class="score-item">
                    <div class="score-label">Perfect</div>
                    <div class="score-value" id="perfect">0</div>
                </div>
            </div>
        </div>
        
        <!-- Middle: Info -->
        <div id="info-section">
            <div class="device-selector">
                <button class="device-btn active" data-device="transistor" onclick="game.selectDevice('transistor')">‚ö° Switch</button>
                <button class="device-btn" data-device="memory" onclick="game.selectDevice('memory')">üíæ Memory</button>
                <button class="device-btn" data-device="power" onclick="game.selectDevice('power')">üîã Power</button>
            </div>
            
            <div class="progress-container">
                <div class="progress-header">
                    <div class="progress-title">Building Progress</div>
                    <div class="progress-percentage" id="progress-text">0%</div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress"></div>
                </div>
            </div>
            
            <div class="layer-info">
                <div class="layer-current" id="current-layer">Get Ready!</div>
                <div class="layer-description" id="layer-description">
                    Position pieces to match the pattern on the right
                </div>
                <div class="layer-fact" id="layer-fact">
                    üí° Modern chips have billions of transistors!
                </div>
            </div>
            
            <div class="controls">
                <div class="controls-title">üéÆ Controls</div>
                <div class="control-row">
                    <span class="key">‚Üê</span>
                    <span class="key">‚Üí</span>
                    <span>Move</span>
                </div>
                <div class="control-row">
                    <span class="key">‚Üë</span>
                    <span class="key">Z</span>
                    <span>Rotate</span>
                </div>
                <div class="control-row">
                    <span class="key">‚Üì</span>
                    <span>Faster</span>
                </div>
                <div class="control-row">
                    <span class="key">Space</span>
                    <span>Drop</span>
                </div>
                <div class="control-row">
                    <span class="key">P</span>
                    <span>Pause</span>
                </div>
            </div>
            
            <button class="restart-btn" onclick="game.restart()">üîÑ New Game</button>
        </div>
        
        <!-- Right: Blueprint -->
        <div id="blueprint-section">
            <div class="blueprint-container">
                <div class="blueprint-title">üèóÔ∏è BUILD PATTERN</div>
                <canvas id="blueprint-canvas" width="280" height="300"></canvas>
                <div class="blueprint-explanation" id="blueprint-explanation">
                    Match this exact pattern! Wrong placement = short circuit!
                </div>
                <div class="layer-list" id="layer-list"></div>
            </div>
        </div>
    </div>
    
    <!-- Popups -->
    <div id="bonus-indicator" class="bonus-popup"></div>
    
    <div id="success-popup" class="popup">
        <h2>üéâ Chip Complete!</h2>
        <p id="success-message">Your chip is ready!</p>
        <button onclick="game.closeSuccessPopup()">Continue</button>
    </div>
    
    <div id="failure-popup" class="popup">
        <h2>‚ö° Short Circuit!</h2>
        <p>Wrong placement! The chip must be rebuilt.</p>
        <p id="failure-details" class="popup-detail"></p>
        <button onclick="game.closeFailurePopup()">Try Again</button>
    </div>
    
    <div id="tutorial-popup" class="popup">
        <h2>How to Play</h2>
        <p>Stack colored blocks to match the pattern on the right. Each color is a different layer of the chip. Wrong placement causes a short circuit!</p>
        <button onclick="game.closeTutorial()">Start Playing</button>
    </div>
    
    <!-- Debug Panel (Press D to toggle) -->
    <div id="debug-panel" class="debug-panel">
        <div id="debug-info"></div>
    </div>

    <script>
        // Game Configuration and Data
        const GAME_CONFIG = {
            COLS: 10,
            ROWS: 20,
            BLOCK_SIZE: 30,
            DROP_SPEED_BASE: 800,
            DROP_SPEED_MIN: 100,
            SCORE_BONUS_PERFECT: 500,
            SCORE_BONUS_NORMAL: 100,
            SCORE_BONUS_CHIP: 2000,
            SCORE_HARD_DROP: 2
        };
        
        const SUCCESS_MESSAGES = {
            transistor: [
                "You just fabricated the logic switch that steers a jet engine controller!",
                "That transistor now routes signals inside a PlayStation-class graphics chip!",
                "Your switch balances power rails in a self-driving car computer!"
            ],
            memory: [
                "You just built the DRAM stack buffering photos on an iPhone!",
                "These memory cells cache telemetry inside a weather satellite!",
                "Your memory die keeps patient scans ready inside an MRI workstation!"
            ],
            power: [
                "You just assembled the power chip that keeps a long-range drone aloft!",
                "This regulator now balances the battery pack of an electric vehicle!",
                "Your PMIC stabilizes the supply inside a wearable heart monitor!"
            ]
        };
        
        const DEVICES = {
            transistor: {
                name: 'Logic Switch',
                icon: '‚ö°',
                blueprintExplanation: 'Assemble the transistor front-end: wafer, isolation, gate stack, and copper contacts.',
                layers: [
                    {
                        name: 'Silicon Wafer',
                        color: '#6366F1',
                        pattern: [
                            [1,1,1,1,1,1,1,1],
                            [1,1,1,1,1,1,1,1],
                            [1,1,1,1,1,1,1,1],
                            [1,1,1,1,1,1,1,1]
                        ],
                        description: 'Polished 300 mm silicon forms the base die.',
                        fact: 'One wafer can hold over 5,000 logic chips.'
                    },
                    {
                        name: 'Isolation Wells',
                        color: '#F59E0B',
                        pattern: [
                            [1,1,0,0,0,0,1,1],
                            [1,0,0,0,0,0,0,1],
                            [1,0,0,0,0,0,0,1],
                            [1,1,0,0,0,0,1,1]
                        ],
                        description: 'Shallow trenches keep neighboring devices electrically separate.',
                        fact: 'Silicon dioxide fills the trenches to block leakage current.'
                    },
                    {
                        name: 'Gate Stack',
                        color: '#EF4444',
                        pattern: [
                            [0,0,1,1,1,1,0,0],
                            [0,1,1,1,1,1,1,0],
                            [0,1,1,1,1,1,1,0]
                        ],
                        description: 'High-k dielectrics and polysilicon control the channel.',
                        fact: 'Gate oxides are thinner than a strand of DNA.'
                    },
                    {
                        name: 'Metal Contacts',
                        color: '#22D3EE',
                        pattern: [
                            [1,1,0,0,0,0,1,1],
                            [1,1,0,0,0,0,1,1],
                            [1,1,0,0,0,0,1,1]
                        ],
                        description: 'Tungsten plugs and copper lines carry signals out.',
                        fact: 'Dual-damascene copper routes billions of connections.'
                    }
                ]
            },
            memory: {
                name: 'Memory Stack',
                icon: 'üíæ',
                blueprintExplanation: 'Build a DRAM cell: substrate, isolation grid, capacitor array, and bond pads.',
                layers: [
                    {
                        name: 'Silicon Substrate',
                        color: '#8B5CF6',
                        pattern: [
                            [1,1,1,1,1,1,1,1],
                            [1,1,1,1,1,1,1,1],
                            [1,1,1,1,1,1,1,1],
                            [1,1,1,1,1,1,1,1]
                        ],
                        description: 'Lightly doped silicon hosts the memory array.',
                        fact: 'DRAM starts with p-type wells etched into the wafer.'
                    },
                    {
                        name: 'Isolation Grid',
                        color: '#EC4899',
                        pattern: [
                            [1,0,1,0,1,0,1,0],
                            [1,0,1,0,1,0,1,0],
                            [1,0,1,0,1,0,1,0],
                            [1,1,1,1,1,1,1,1]
                        ],
                        description: 'Word-line trenches stop cells from sharing charge.',
                        fact: 'Shallow trench isolation lets billions of bits stay independent.'
                    },
                    {
                        name: 'Capacitor Array',
                        color: '#06B6D4',
                        pattern: [
                            [0,1,1,0,1,1,0,1],
                            [1,1,1,1,1,1,1,1],
                            [0,1,1,0,1,1,0,1]
                        ],
                        description: 'Stacked capacitors store the 0s and 1s.',
                        fact: 'Each DRAM cell holds roughly 30 femtofarads of charge.'
                    },
                    {
                        name: 'Bond Pads',
                        color: '#F97316',
                        pattern: [
                            [1,0,0,1,0,0,1,0],
                            [0,1,1,0,1,1,0,1]
                        ],
                        description: 'Top metal pads connect the die to the package.',
                        fact: 'Gold or copper wires stitch pads to the substrate leads.'
                    }
                ]
            },
            power: {
                name: 'Power Manager',
                icon: 'üîã',
                blueprintExplanation: 'Package a power IC: thick substrate, copper planes, FET array, and solder bumps.',
                layers: [
                    {
                        name: 'Power Substrate',
                        color: '#DC2626',
                        pattern: [
                            [1,1,1,1,1,1,1,1],
                            [1,1,1,1,1,1,1,1],
                            [1,1,1,1,1,1,1,1],
                            [1,1,1,1,1,1,1,1]
                        ],
                        description: 'Thick epitaxial silicon spreads heat from the die.',
                        fact: 'Power devices use low-resistance silicon to handle high currents.'
                    },
                    {
                        name: 'Copper Planes',
                        color: '#F59E0B',
                        pattern: [
                            [1,0,0,1,0,0,1,0],
                            [1,0,0,1,0,0,1,0],
                            [1,1,1,1,1,1,1,1],
                            [1,0,0,1,0,0,1,0]
                        ],
                        description: 'Wide copper planes distribute battery power evenly.',
                        fact: 'Redistribution layers are electroplated just microns thick.'
                    },
                    {
                        name: 'Control FET Array',
                        color: '#7C3AED',
                        pattern: [
                            [1,0,1,0,1,0,1,0],
                            [1,1,1,1,1,1,1,1],
                            [1,0,1,0,1,0,1,0]
                        ],
                        description: 'Synchronous MOSFETs regulate voltage to each rail.',
                        fact: 'Modern PMICs can switch hundreds of thousands of times per second.'
                    },
                    {
                        name: 'Solder Bumps',
                        color: '#A855F7',
                        pattern: [
                            [1,0,1,0,1,0,1,0]
                        ],
                        description: 'Flip-chip bumps tie the die into the circuit board.',
                        fact: 'Lead-free solder spheres form ball grid arrays for power chips.'
                    }
                ]
            }
        };
        
        // Game Class
        class ChipFactoryGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.blueprintCanvas = document.getElementById('blueprint-canvas');
                this.bpCtx = this.blueprintCanvas.getContext('2d');
                
                this.board = [];
                this.targetPattern = [];
                this.currentDevice = 'transistor';
                this.currentLayerIndex = 0;
                this.currentPiece = null;
                this.score = 0;
                this.devicesBuilt = 0;
                this.perfectPlacements = 0;
                this.isPaused = false;
                this.dropCounter = 0;
                this.lastTime = 0;
                this.debugMode = false;
                this.lastPlacementStats = null;
                
                this.init();
                this.gameLoop();
                
                // Event listeners
                document.addEventListener('keydown', (e) => this.handleKeyPress(e));
                
                // Debug mode toggle
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'd' || e.key === 'D') {
                        this.toggleDebug();
                    }
                });
            }
            
            init() {
                // Initialize empty board
                this.board = Array(GAME_CONFIG.ROWS).fill().map(() => 
                    Array(GAME_CONFIG.COLS).fill(null)
                );
                
                // Reset game state
                this.currentLayerIndex = 0;
                this.isPaused = false;
                this.lastPlacementStats = null;
                
                // Build target pattern for current device
                this.buildTargetPattern();
                
                // Update UI
                this.updateDeviceBlueprint();
                this.updateLayerInfo();
                this.updateProgress();
                
                // Spawn first piece
                this.spawnPiece();
            }
            
            buildTargetPattern() {
                // Create the exact pattern we expect the player to build
                this.targetPattern = Array(GAME_CONFIG.ROWS).fill().map(() => 
                    Array(GAME_CONFIG.COLS).fill(null)
                );
                
                const device = DEVICES[this.currentDevice];
                
                // Determine the widest layer so we can center everything consistently
                const maxWidth = device.layers.reduce((widest, layer) => 
                    Math.max(widest, layer.pattern[0].length), 0
                );
                const startX = Math.floor((GAME_CONFIG.COLS - maxWidth) / 2);

                // Track where each layer should start vertically (top row index)
                this.layerStartY = Array(device.layers.length).fill(0);

                // Start from the bottom of the board and stack layers upward
                let currentY = GAME_CONFIG.ROWS;
                device.layers.forEach((layer, layerIndex) => {
                    const layerHeight = layer.pattern.length;
                    const layerTopY = currentY - layerHeight;
                    const layerWidth = layer.pattern[0].length;
                    const xOffset = startX + Math.floor((maxWidth - layerWidth) / 2);

                    this.layerStartY[layerIndex] = layerTopY;

                    layer.pattern.forEach((row, rowIndex) => {
                        row.forEach((cell, colIndex) => {
                            if (cell === 1) {
                                const x = xOffset + colIndex;
                                const y = layerTopY + rowIndex;
                                if (x >= 0 && x < GAME_CONFIG.COLS && y >= 0 && y < GAME_CONFIG.ROWS) {
                                    this.targetPattern[y][x] = {
                                        color: layer.color,
                                        layerIndex,
                                        required: true
                                    };
                                }
                            }
                        });
                    });

                    currentY = layerTopY;
                });

                this.targetStartX = startX;
                this.targetStartY = currentY;
            }
            
            spawnPiece() {
                const device = DEVICES[this.currentDevice];
                if (this.currentLayerIndex >= device.layers.length) {
                    this.completeDevice();
                    return;
                }
                
                const layer = device.layers[this.currentLayerIndex];
                const spawnY = 0;

                // Always spawn the piece rotated so players must re-orient it
                const originalPattern = JSON.parse(JSON.stringify(layer.pattern));
                const rotations = [90, 270];
                const forcedRotation = rotations[Math.floor(Math.random() * rotations.length)];
                
                let rotatedPattern = originalPattern;
                for (let step = 0; step < forcedRotation / 90; step++) {
                    rotatedPattern = this.rotateMatrix(rotatedPattern);
                }

                const defaultX = Math.floor((GAME_CONFIG.COLS - rotatedPattern[0].length) / 2);

                this.currentPiece = {
                    pattern: rotatedPattern,
                    color: layer.color,
                    layerIndex: this.currentLayerIndex,
                    x: defaultX,
                    y: spawnY,
                    rotation: forcedRotation % 360
                };

                // Check for game over
                if (this.checkCollision(this.currentPiece)) {
                    this.gameOver();
                }
            }
            
            checkCollision(piece, offsetX = 0, offsetY = 0) {
                // Standard Tetris-style collision check
                for (let row = 0; row < piece.pattern.length; row++) {
                    for (let col = 0; col < piece.pattern[row].length; col++) {
                        if (piece.pattern[row][col] === 1) {
                            const newX = piece.x + col + offsetX;
                            const newY = piece.y + row + offsetY;
                            
                            // Check boundaries
                            if (newX < 0 || newX >= GAME_CONFIG.COLS || 
                                newY >= GAME_CONFIG.ROWS) {
                                return true;
                            }
                            
                            // Check board collision with any existing blocks
                            if (newY >= 0 && this.board[newY][newX] !== null) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            rotatePiece() {
                if (!this.currentPiece || this.isPaused) return;
                
                const oldPattern = this.currentPiece.pattern;
                const rotated = this.rotateMatrix(oldPattern);
                
                this.currentPiece.pattern = rotated;
                
                // Try to fit the rotated piece
                if (this.checkCollision(this.currentPiece)) {
                    // Try wall kicks
                    const kicks = [[0, 0], [-1, 0], [1, 0], [0, -1], [-2, 0], [2, 0]];
                    let kicked = false;
                    
                    for (let [dx, dy] of kicks) {
                        if (!this.checkCollision(this.currentPiece, dx, dy)) {
                            this.currentPiece.x += dx;
                            this.currentPiece.y += dy;
                            kicked = true;
                            break;
                        }
                    }
                    
                    if (!kicked) {
                        // Revert rotation
                        this.currentPiece.pattern = oldPattern;
                    }
                }
                
                this.currentPiece.rotation = (this.currentPiece.rotation + 90) % 360;
            }
            
            rotateMatrix(matrix) {
                const rows = matrix.length;
                const cols = matrix[0].length;
                const rotated = Array(cols).fill().map(() => Array(rows).fill(0));
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        rotated[col][rows - 1 - row] = matrix[row][col];
                    }
                }
                
                return rotated;
            }
            
            movePiece(dx) {
                if (!this.currentPiece || this.isPaused) return;
                
                if (!this.checkCollision(this.currentPiece, dx, 0)) {
                    this.currentPiece.x += dx;
                }
            }
            
            dropPiece() {
                if (!this.currentPiece || this.isPaused) return;
                
                if (!this.checkCollision(this.currentPiece, 0, 1)) {
                    this.currentPiece.y++;
                    this.dropCounter = 0;
                    return true;
                } else {
                    this.lockPiece();
                    return false;
                }
            }
            
            hardDrop() {
                if (!this.currentPiece || this.isPaused) return;
                
                let drops = 0;
                while (!this.checkCollision(this.currentPiece, 0, 1)) {
                    this.currentPiece.y++;
                    drops++;
                }
                
                this.score += drops * GAME_CONFIG.SCORE_HARD_DROP;
                this.updateScore();
                this.lockPiece();
            }
            
            lockPiece() {
                if (!this.currentPiece) return;

                const placedPiece = this.currentPiece;

                // First lock the piece in place like standard Tetris
                for (let row = 0; row < placedPiece.pattern.length; row++) {
                    for (let col = 0; col < placedPiece.pattern[row].length; col++) {
                        if (placedPiece.pattern[row][col] === 1) {
                            const boardX = placedPiece.x + col;
                            const boardY = placedPiece.y + row;
                            
                            if (boardY >= 0 && boardY < GAME_CONFIG.ROWS && 
                                boardX >= 0 && boardX < GAME_CONFIG.COLS) {
                                this.board[boardY][boardX] = {
                                    color: placedPiece.color,
                                    layerIndex: placedPiece.layerIndex
                                };
                            }
                        }
                    }
                }

                const stats = this.getLayerStats(this.currentLayerIndex);
                this.lastPlacementStats = stats;
                this.debugLog(`Lock stats ‚Üí expected=${stats.expected}, matching=${stats.matching}, extra=${stats.extra}`);
                this.updateDebugInfo();

                // Clear current piece before deciding next state
                this.currentPiece = null;

                if (stats.matching !== stats.expected || stats.extra > 0) {
                    this.triggerShortCircuit(stats);
                    return;
                }

                const perfectOrientation = (placedPiece.rotation % 360) === 0;
                const isPerfect = stats.extra === 0 && stats.matching === stats.expected && perfectOrientation;

                if (isPerfect) {
                    this.score += GAME_CONFIG.SCORE_BONUS_PERFECT;
                    this.perfectPlacements++;
                    this.showBonus('‚ú® PERFECT! +' + GAME_CONFIG.SCORE_BONUS_PERFECT);
                } else {
                    this.score += GAME_CONFIG.SCORE_BONUS_NORMAL;
                }
                
                this.currentLayerIndex++;
                this.updateProgress();
                this.updateLayerInfo();
                this.updateScore();
                this.updateDeviceBlueprint();
                
                // Spawn next piece or complete device
                if (this.currentLayerIndex >= DEVICES[this.currentDevice].layers.length) {
                    this.completeDevice();
                } else {
                    this.spawnPiece();
                }
            }
            
            getLayerStats(layerIndex) {
                let expected = 0;
                let matching = 0;
                let extra = 0;

                for (let y = 0; y < GAME_CONFIG.ROWS; y++) {
                    for (let x = 0; x < GAME_CONFIG.COLS; x++) {
                        const target = this.targetPattern[y][x];
                        const board = this.board[y][x];

                        if (target && target.layerIndex === layerIndex) {
                            expected++;
                            if (board && board.layerIndex === layerIndex) {
                                matching++;
                            }
                        } else if (board && board.layerIndex === layerIndex) {
                            extra++;
                        }
                    }
                }

                return { expected, matching, extra };
            }
            
            validatePlacement() {
                if (!this.currentPiece) return false;

                const layerIndex = this.currentPiece.layerIndex;
                const stats = { expected: 0, matching: 0, extra: 0 };

                // Count expected cells for this layer from the target pattern
                for (let y = 0; y < GAME_CONFIG.ROWS; y++) {
                    for (let x = 0; x < GAME_CONFIG.COLS; x++) {
                        const target = this.targetPattern[y][x];
                        if (target && target.layerIndex === layerIndex) {
                            stats.expected++;
                        }
                    }
                }

                // Evaluate current piece position against target pattern
                for (let row = 0; row < this.currentPiece.pattern.length; row++) {
                    for (let col = 0; col < this.currentPiece.pattern[row].length; col++) {
                        if (this.currentPiece.pattern[row][col] !== 1) continue;

                        const boardX = this.currentPiece.x + col;
                        const boardY = this.currentPiece.y + row;

                        if (boardY < 0 || boardY >= GAME_CONFIG.ROWS || boardX < 0 || boardX >= GAME_CONFIG.COLS) {
                            return false;
                        }

                        const target = this.targetPattern[boardY][boardX];
                        const occupied = this.board[boardY][boardX];

                        if (occupied && occupied.layerIndex !== layerIndex) {
                            stats.extra++;
                        } else if (target && target.layerIndex === layerIndex) {
                            stats.matching++;
                        } else {
                            stats.extra++;
                        }
                    }
                }

                this.debugLog(`Preview stats ‚Üí expected=${stats.expected}, matching=${stats.matching}, extra=${stats.extra}`);

                return stats.matching === stats.expected && stats.extra === 0;
            }
            
            checkPerfectAlignment() {
                // For now, just check if the piece matches the target pattern cells exactly
                const matchesTarget = this.validatePlacement();
                // And check if it's not rotated
                const notRotated = (this.currentPiece.rotation % 360) === 0;
                return matchesTarget && notRotated;
            }
            
            triggerShortCircuit(stats) {
                this.canvas.classList.add('short-circuit');
                document.getElementById('failure-popup').classList.add('active');
                
                const details = document.getElementById('failure-details');
                if (details && stats) {
                    details.textContent = `Expected ${stats.expected}, matched ${stats.matching}, extra ${stats.extra}.`;
                } else if (details) {
                    details.textContent = '';
                }
                
                // Pause game during popup
                this.isPaused = true;
                
                // Don't auto-reset, wait for user to click
            }
            
            closeFailurePopup() {
                document.getElementById('failure-popup').classList.remove('active');
                this.canvas.classList.remove('short-circuit');
                
                const details = document.getElementById('failure-details');
                if (details) {
                    details.textContent = '';
                }
                this.lastPlacementStats = null;
                this.updateDebugInfo();
                
                // Reset the chip area
                this.clearChipArea();
                
                // Reset to first layer
                this.currentLayerIndex = 0;
                this.updateProgress();
                this.updateLayerInfo();
                this.updateDeviceBlueprint();
                
                // Unpause and spawn new piece
                this.isPaused = false;
                this.spawnPiece();
            }
            
            clearChipArea() {
                // Clear board from target start position downwards
                const startY = this.targetStartY !== undefined ? this.targetStartY : 0;
                for (let y = startY; y < GAME_CONFIG.ROWS; y++) {
                    for (let x = 0; x < GAME_CONFIG.COLS; x++) {
                        this.board[y][x] = null;
                    }
                }
            }
            
            completeDevice() {
                this.devicesBuilt++;
                this.score += GAME_CONFIG.SCORE_BONUS_CHIP;
                
                // Show success message
                const messages = SUCCESS_MESSAGES[this.currentDevice];
                const message = messages[Math.floor(Math.random() * messages.length)];
                document.getElementById('success-message').textContent = message;
                document.getElementById('success-popup').classList.add('active');
                
                this.updateScore();
            }
            
            closeSuccessPopup() {
                document.getElementById('success-popup').classList.remove('active');
                
                // Clear and restart
                this.clearChipArea();
                this.currentLayerIndex = 0;
                this.lastPlacementStats = null;
                this.updateDebugInfo();
                
                // Rebuild target pattern (could be at different position)
                this.buildTargetPattern();
                
                this.updateProgress();
                this.updateLayerInfo();
                this.updateDeviceBlueprint();
                this.spawnPiece();
            }
            
            gameOver() {
                this.isPaused = true;
                this.showBonus('Game Over! Score: ' + this.score);
                setTimeout(() => this.restart(), 3000);
            }
            
            restart() {
                this.score = 0;
                this.devicesBuilt = 0;
                this.perfectPlacements = 0;
                this.updateScore();
                this.init();
            }
            
            selectDevice(deviceType) {
                if (deviceType === this.currentDevice) return;
                if (this.currentLayerIndex > 0) return; // Don't switch mid-build
                
                this.currentDevice = deviceType;
                
                // Update UI
                document.querySelectorAll('.device-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.device === deviceType) {
                        btn.classList.add('active');
                    }
                });
                
                this.init();
            }
            
            // UI Updates
            updateScore() {
                document.getElementById('score').textContent = this.score.toLocaleString();
                document.getElementById('devices').textContent = this.devicesBuilt;
                document.getElementById('perfect').textContent = this.perfectPlacements;
            }
            
            updateProgress() {
                const device = DEVICES[this.currentDevice];
                const progress = (this.currentLayerIndex / device.layers.length) * 100;
                
                document.getElementById('progress').style.width = progress + '%';
                document.getElementById('progress-text').textContent = Math.round(progress) + '%';
            }
            
            updateLayerInfo() {
                const device = DEVICES[this.currentDevice];
                
                if (this.currentLayerIndex < device.layers.length) {
                    const layer = device.layers[this.currentLayerIndex];
                    document.getElementById('current-layer').textContent = 
                        `Layer ${this.currentLayerIndex + 1}: ${layer.name}`;
                    document.getElementById('layer-description').textContent = layer.description;
                    document.getElementById('layer-fact').textContent = `üí° ${layer.fact}`;
                } else {
                    document.getElementById('current-layer').textContent = 'Chip Complete!';
                    document.getElementById('layer-description').textContent = 'Great job building the chip!';
                    document.getElementById('layer-fact').textContent = 'üí° Ready for the next one!';
                }
            }
            
            updateDeviceBlueprint() {
                const device = DEVICES[this.currentDevice];
                
                // Clear canvas
                this.bpCtx.fillStyle = '#0a0a0a';
                this.bpCtx.fillRect(0, 0, this.blueprintCanvas.width, this.blueprintCanvas.height);
                
                // Update explanation
                document.getElementById('blueprint-explanation').textContent = device.blueprintExplanation;
                
                // Calculate dimensions
                let totalHeight = 0;
                device.layers.forEach(layer => {
                    totalHeight += layer.pattern.length;
                });

                const maxWidth = device.layers.reduce((widest, layer) => 
                    Math.max(widest, layer.pattern[0].length), 0
                );
                
                const scale = Math.min(25, (this.blueprintCanvas.height - 40) / totalHeight);
                const xOffset = (this.blueprintCanvas.width - maxWidth * scale) / 2;
                const yStart = (this.blueprintCanvas.height - totalHeight * scale) / 2;
                
                // Draw layers from bottom up to match the game board
                let yOffset = yStart + totalHeight * scale;
                for (let i = 0; i < device.layers.length; i++) {
                    const layer = device.layers[i];
                    const layerHeight = layer.pattern.length * scale;
                    yOffset -= layerHeight;
                    const layerWidth = layer.pattern[0].length;
                    const layerXOffset = xOffset + Math.floor((maxWidth - layerWidth) / 2) * scale;
                    
                    const opacity = i <= this.currentLayerIndex ? 1 : 0.3;
                    this.bpCtx.globalAlpha = opacity;
                    
                    layer.pattern.forEach((row, rowIndex) => {
                        row.forEach((cell, colIndex) => {
                            if (cell === 1) {
                                this.drawBlock(
                                    layerXOffset + colIndex * scale,
                                    yOffset + rowIndex * scale,
                                    scale - 1,
                                    layer.color,
                                    this.bpCtx
                                );
                            }
                        });
                    });
                    
                    if (i === this.currentLayerIndex) {
                        this.bpCtx.globalAlpha = 1;
                        this.bpCtx.strokeStyle = '#667eea';
                        this.bpCtx.lineWidth = 2;
                        this.bpCtx.setLineDash([5, 5]);
                        this.bpCtx.strokeRect(
                            layerXOffset - 5,
                            yOffset - 5,
                            layerWidth * scale + 10,
                            layer.pattern.length * scale + 10
                        );
                        this.bpCtx.setLineDash([]);
                    }
                }
                
                this.bpCtx.globalAlpha = 1;
                
                // Update layer list
                const layerList = document.getElementById('layer-list');
                layerList.innerHTML = device.layers.map((layer, index) => `
                    <div class="layer-item ${index === this.currentLayerIndex ? 'active' : ''} 
                                           ${index < this.currentLayerIndex ? 'completed' : ''}">
                        <div class="layer-indicator"></div>
                        <span>${index + 1}. ${layer.name}</span>
                    </div>
                `).join('');
            }
            
            showBonus(text) {
                const indicator = document.getElementById('bonus-indicator');
                indicator.textContent = text;
                indicator.classList.remove('bonus-active');
                void indicator.offsetWidth; // Force reflow
                indicator.classList.add('bonus-active');
            }
            
            showTutorial() {
                document.getElementById('tutorial-popup').classList.add('active');
                this.isPaused = true;
            }
            
            closeTutorial() {
                document.getElementById('tutorial-popup').classList.remove('active');
                this.isPaused = false;
            }
            
            // Drawing methods
            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#0a0a0a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                this.ctx.strokeStyle = 'rgba(102, 126, 234, 0.03)';
                this.ctx.lineWidth = 1;
                for (let i = 0; i <= GAME_CONFIG.COLS; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i * GAME_CONFIG.BLOCK_SIZE, 0);
                    this.ctx.lineTo(i * GAME_CONFIG.BLOCK_SIZE, this.canvas.height);
                    this.ctx.stroke();
                }
                for (let i = 0; i <= GAME_CONFIG.ROWS; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i * GAME_CONFIG.BLOCK_SIZE);
                    this.ctx.lineTo(this.canvas.width, i * GAME_CONFIG.BLOCK_SIZE);
                    this.ctx.stroke();
                }
                
                // Draw target guide (ghost pieces)
                if (!this.isPaused && this.currentPiece) {
                    for (let y = 0; y < GAME_CONFIG.ROWS; y++) {
                        for (let x = 0; x < GAME_CONFIG.COLS; x++) {
                            if (this.targetPattern[y][x] && 
                                this.targetPattern[y][x].layerIndex === this.currentLayerIndex &&
                                !this.board[y][x]) {
                                
                                this.ctx.fillStyle = 'rgba(102, 126, 234, 0.15)';
                                this.ctx.fillRect(
                                    x * GAME_CONFIG.BLOCK_SIZE,
                                    y * GAME_CONFIG.BLOCK_SIZE,
                                    GAME_CONFIG.BLOCK_SIZE,
                                    GAME_CONFIG.BLOCK_SIZE
                                );
                                
                                this.ctx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
                                this.ctx.setLineDash([5, 5]);
                                this.ctx.strokeRect(
                                    x * GAME_CONFIG.BLOCK_SIZE + 1,
                                    y * GAME_CONFIG.BLOCK_SIZE + 1,
                                    GAME_CONFIG.BLOCK_SIZE - 2,
                                    GAME_CONFIG.BLOCK_SIZE - 2
                                );
                                this.ctx.setLineDash([]);
                            }
                        }
                    }
                }
                
                // Draw board
                for (let y = 0; y < GAME_CONFIG.ROWS; y++) {
                    for (let x = 0; x < GAME_CONFIG.COLS; x++) {
                        if (this.board[y][x]) {
                            this.drawBlock(
                                x * GAME_CONFIG.BLOCK_SIZE,
                                y * GAME_CONFIG.BLOCK_SIZE,
                                GAME_CONFIG.BLOCK_SIZE,
                                this.board[y][x].color,
                                this.ctx
                            );
                        }
                    }
                }
                
                // Draw current piece
                if (this.currentPiece && !this.isPaused) {
                    const isPerfect = this.checkPerfectAlignment();
                    
                    for (let row = 0; row < this.currentPiece.pattern.length; row++) {
                        for (let col = 0; col < this.currentPiece.pattern[row].length; col++) {
                            if (this.currentPiece.pattern[row][col] === 1) {
                                this.drawBlock(
                                    (this.currentPiece.x + col) * GAME_CONFIG.BLOCK_SIZE,
                                    (this.currentPiece.y + row) * GAME_CONFIG.BLOCK_SIZE,
                                    GAME_CONFIG.BLOCK_SIZE,
                                    this.currentPiece.color,
                                    this.ctx
                                );
                            }
                        }
                    }
                    
                    // Perfect alignment glow
                    if (isPerfect) {
                        this.ctx.strokeStyle = '#34C759';
                        this.ctx.lineWidth = 3;
                        this.ctx.shadowColor = '#34C759';
                        this.ctx.shadowBlur = 10;
                        
                        const bounds = this.getPieceBounds(this.currentPiece);
                        this.ctx.strokeRect(
                            this.currentPiece.x * GAME_CONFIG.BLOCK_SIZE,
                            this.currentPiece.y * GAME_CONFIG.BLOCK_SIZE,
                            bounds.width * GAME_CONFIG.BLOCK_SIZE,
                            bounds.height * GAME_CONFIG.BLOCK_SIZE
                        );
                        this.ctx.shadowBlur = 0;
                    }
                }
                
                // Pause overlay
                if (this.isPaused) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 24px sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2);
                }
            }
            
            drawBlock(x, y, size, color, context) {
                const padding = 1;
                
                // Main block with gradient
                const gradient = context.createLinearGradient(x, y, x + size, y + size);
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, this.adjustColor(color, -20));
                context.fillStyle = gradient;
                context.fillRect(x + padding, y + padding, size - padding * 2, size - padding * 2);
                
                // Highlight
                context.fillStyle = this.adjustColor(color, 40);
                context.fillRect(x + padding, y + padding, size - padding * 2, 2);
                context.fillRect(x + padding, y + padding, 2, size - padding * 2);
            }
            
            adjustColor(color, amount) {
                const num = parseInt(color.replace("#", ""), 16);
                const r = Math.min(255, Math.max(0, (num >> 16) + amount));
                const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));
                const b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));
                return "#" + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
            }
            
            getPieceBounds(piece) {
                let width = 0, height = piece.pattern.length;
                for (let row of piece.pattern) {
                    width = Math.max(width, row.length);
                }
                return { width, height };
            }
            
            // Input handling
            handleKeyPress(e) {
                if (!this.currentPiece) return;
                
                switch(e.key.toLowerCase()) {
                    case 'arrowleft':
                        this.movePiece(-1);
                        break;
                    case 'arrowright':
                        this.movePiece(1);
                        break;
                    case 'arrowup':
                    case 'z':
                        this.rotatePiece();
                        break;
                    case 'arrowdown':
                        if (this.dropPiece()) {
                            this.score++;
                            this.updateScore();
                        }
                        break;
                    case ' ':
                        e.preventDefault();
                        this.hardDrop();
                        break;
                    case 'p':
                        this.isPaused = !this.isPaused;
                        break;
                }
            }
            
            // Game loop
            gameLoop(time = 0) {
                if (!this.isPaused) {
                    const deltaTime = time - this.lastTime;
                    this.lastTime = time;
                    
                    this.dropCounter += deltaTime;
                    const dropSpeed = Math.max(
                        GAME_CONFIG.DROP_SPEED_MIN,
                        GAME_CONFIG.DROP_SPEED_BASE - Math.floor(this.score / 1000) * 50
                    );
                    
                    if (this.dropCounter > dropSpeed) {
                        this.dropPiece();
                    }
                    
                    this.draw();
                }
                
                requestAnimationFrame((t) => this.gameLoop(t));
            }
            
            // Debug methods
            toggleDebug() {
                this.debugMode = !this.debugMode;
                document.getElementById('debug-panel').classList.toggle('active');
                
                if (this.debugMode) {
                    this.updateDebugInfo();
                }
            }
            
            debugLog(message) {
                if (this.debugMode) {
                    console.log('[DEBUG]', message);
                    const debugInfo = document.getElementById('debug-info');
                    debugInfo.innerHTML = message + '<br>' + debugInfo.innerHTML;
                    if (debugInfo.children.length > 10) {
                        debugInfo.innerHTML = debugInfo.innerHTML.split('<br>').slice(0, 10).join('<br>');
                    }
                }
            }
            
            updateDebugInfo() {
                if (!this.debugMode) return;
                
                const info = [
                    `Device: ${this.currentDevice}`,
                    `Layer: ${this.currentLayerIndex}`,
                    `Score: ${this.score}`,
                    `Piece: ${this.currentPiece ? `(${this.currentPiece.x}, ${this.currentPiece.y})` : 'none'}`,
                    `Target: (${this.targetStartX}, ${this.targetStartY})`
                ];

                if (this.lastPlacementStats) {
                    const { expected, matching, extra } = this.lastPlacementStats;
                    info.push(`Stats: exp=${expected}, match=${matching}, extra=${extra}`);
                }
                
                document.getElementById('debug-info').innerHTML = info.join('<br>');
            }
        }
        
        // Initialize game when page loads
        let game;
        window.addEventListener('DOMContentLoaded', () => {
            game = new ChipFactoryGame();
        });
    </script>
</body>
</html>
